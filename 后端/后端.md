# 笔记

如果要在后端向前端返回某两个实体类有相互重合的json数据，可以在其中一个实体类添加一个map<String, Object>字段，并使用注解@TableField(exist = false) （mybatis-plus）来进行排除ORM映射。

```
public class User{
	@TableId(type = IdType.AUTO)
	private Integer id;
	
	private String name;
	
	@TableField(exist = false)
	private Map<String, Object> core;
}
```



# Springboot

### 1、日期问题

在实体类的类型为Date时，从前端传来后端的数据类型为String，需要转换为Date。可以在实体类中使用注释来告诉Springboot要将此属性格式化为日期类型

```
@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss")
```

### 2、layui模板

###### layer.open

type类型共有：

![image-20240416150715029](./assets/image-20240416150715029.png)



### 3、JSON

springboot默认带有jackson工具。使用starter引入时，无需再添加依赖。

#### jackson工具类

在服务端，如果使用JSON格式接收数据的话，可以使用JsonNode类型表示JSON类型。需引入依赖

```
<dependency>
    <groupId>com.fasterxml.jackson.datatype</groupId>
    <artifactId>jackson-datatype-jsr310</artifactId>
    <version>2.15.4</version>
</dependency>
```



##### ObjectMapper

###### 配置

使用bean全局配置：将null值的字段进行过滤，不返回。作为后端接口的返回值。

```
	@Bean
    public ObjectMapper objectMapper() {
        ObjectMapper mapper = new ObjectMapper();
        mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
        return mapper;
    }
```

使用类局部配置：

```
// 忽略未知属性，即类中没有的属性不抛出异常
ObjectMapper objectMapper = new ObjectMapper();
objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
```



###### 使用

java对象和Json数据相互转换的类。

- 序列化：将对象类转换为JSON

```
@Data
class user{
    private String userName;
    private String userPwd;
}

{
	ObjectMapper mapper = new ObjectMapper();
	String str = mapper.writeValueAsString(user);
}

```

- 反序列化：将JSON变为对象。或者以节点的形式

```
String json = "{\"userName\":\"John\",\"userPwd\":30}";
ObjectMapper mapper = new ObjectMapper();
mapper.readValue(json, user.class);

// 节点
JsonNode node = objectMapper.readTree(json);
```







##### JsonNode

###### 常见用法：

- `get(String fieldName)`: 获取指定字段名的子节点。
- `asText()`: 将节点的值转换为字符串。
- `asInt()`: 将节点的值转换为整数。
- `asBoolean()`: 将节点的值转换为布尔值。
- `isArray()`: 检查节点是否为数组。
- `isObject()`: 检查节点是否为对象。
- `elements()`: 返回一个迭代器，用于遍历数组节点中的所有元素。















#### org.json工具类

引入

```xml
<dependency>
    <groupId>org.json</groupId>
    <artifactId>json</artifactId>
    <version>20220320</version> <!-- 或者你想要使用的最新版本 -->
</dependency>
```

##### 字符串转JSON

可以直接使用JsonObject的构造方法将String类型转换为json。如下列代码。

```java
String str = "{
	"id": 1,
	"name": "Jon"
}"
JSONObject json = new JsonObject(str);
```

要取出json中的节点，可以先进行判断是否有该节点再进行获取

建议使用opt，opt方法不会抛出异常。

```java
if( !json.isNULL("id") ){	// 或json.has("id")
	int id = json.getInt("id");		// 使用json.optInt("id")
}
```



##### 添加节点

使用put添加json节点

```java
JSONObject json = new JsonObeject();
json.put("")
```





### 4、mybatis-plus

#### Db工具类

提供了一种快捷的方式来进行数据库操作，简化了代码并提高了开发效率。通过 `Db.lambdaQuery` 方法，可以直接进行查询并选择特定字段。这种方式特别适合快速开发和测试场景。如：

查询符合条件的列表

```java
Db.lambdaQuery(User.class)
    .eq(User::getId, id)
    .select(User::getId,
    User::getUserPwd,
    User::getUserName
    )
    .list();
```

分页查询

```java
Page<User> pageRequest = new Page<>(page, size);
return Db.lambdaQuery(User.class)
    .eq(User::getId, id)
    .select(User::getUserAccount,
        User::getUserPwd,
        User::getUserName
    )
    .page(pageRequest);
```





### 5、发起HTTP请求

在springboot5后，可以使用WebClient作为客户端来进行http请求

#### 依赖：

```java
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
或者下面这个依赖就包含上面这个包
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

#### 配置bean

```java
@Configuration
public class HttpConfig {
    @Bean
    public WebClient.Builder webClientBuilder() {
        return WebClient.builder();
    }
}
```

#### 使用

```java
// 先注入
@Resource
private WebClient.Builder webClientBuilder;

public Boolean getDataFromOtherService() {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("id", id);
        jsonObject.put("url", url);
        jsonObject.put("from_lan", fromLan);
        jsonObject.put("to_lan", toLan);
        
         client.post()
                .uri("/upload")
                .contentType(MediaType.APPLICATION_JSON)
                .body(BodyInserters.fromValue(jsonObject.toString()))
                .retrieve()
                .bodyToMono(String.class)
                .subscribe(response -> System.out.println("Response from server: " + 							response));
    }
```







### 6、正则表达式匹配器

可以使用正则表达式来匹配有固定字符的字符串来得到不定字符

```java
// 输入字符串：/resource/薄荷巧克力/2024-06-09/8.mp4
String patternStr = "/resource/(.*?)/(.*?)/";
// 编译正则表达式
Pattern pattern = Pattern.compile(patternStr);
// 创建匹配器
Matcher matcher = pattern.matcher(url);

// 查找匹配项并提取所需部分，最终结果：把薄荷巧克力和2024-06-09得到
if (matcher.find()) {
    String extractedStr = matcher.group(1) ;
    String dataStr= matcher.group(2);
} else {
    System.out.println("No match found.");
}
```



### 7、定时任务

1、可以使用注解进行定时

```
// 这样指的是每天的h小时，m分，s秒执行
@Scheduled(cron = "s m h * * ?")
```

2、使用ScheduledExecutorService类，下列代码可以通过一个tasks进行存储定时任务

```java
@Service
public class DynamicTaskScheduler {

    @Autowired
    private ScheduledExecutorService scheduledExecutorService;

    private final Map<String, ScheduledFuture<?>> tasks = new ConcurrentHashMap<>();

    public String scheduleTask(String taskId, Runnable task, LocalDateTime startTime) {
        String result = "";
        if (tasks.containsKey(taskId)) {
            cancelTask(taskId);
            result = "更新任务成功！";
        }else{
            result = "添加任务成功！";
        }
        long initialDelay = computeInitialDelay(startTime);
        long period = TimeUnit.DAYS.toMillis(1);

        ScheduledFuture<?> scheduledTask = scheduledExecutorService.scheduleAtFixedRate(task, initialDelay, period, TimeUnit.MILLISECONDS);
        tasks.put(taskId, scheduledTask);

        return result;
    }

    public void cancelTask(String taskId) {
        ScheduledFuture<?> scheduledTask = tasks.remove(taskId);
        if (scheduledTask != null) {
            scheduledTask.cancel(false);
        }
    }

    public String getAllTaskIds(){
        StringBuilder status = new StringBuilder("当前任务列表：\n");
        tasks.forEach((taskId, future) -> {
            status.append("任务ID: ").append(taskId).append(", 状态: ").append(future.isCancelled() ? "已取消" : "运行中").append("\n");
        });
        return status.toString();

    }


    private long computeInitialDelay(LocalDateTime startTime) {
        LocalDateTime now = LocalDateTime.now();
        if (now.isAfter(startTime)) {
            startTime = startTime.plusDays(1);
        }
        return Duration.between(now, startTime).toMillis();
    }
}
```



### 8、Component初始化执行

在bean初始化时执行的函数：

```java
@PostConstruct
public void initialize() {
	System.out.println("初始化！")
}
```



### 9、队列

| 队列类型              | 线程安全 | 阻塞操作 | 主要特点                       |
| --------------------- | -------- | -------- | ------------------------------ |
| BlockingQueue         | 是       | 是       | 适用于生产者-消费者模型        |
| ArrayDeque            | 否       | 否       | 高效的双端队列                 |
| LinkedList            | 否       | 否       | 双向链表实现，支持双端操作     |
| ConcurrentLinkedQueue | 是       | 否       | 高效无锁的并发队列             |
| PriorityQueue         | 否       | 否       | 基于优先级堆，元素按优先级排序 |
| DelayQueue            | 是       | 是       | 支持元素延迟获取               |
| SynchronousQueue      | 是       | 是       | 无缓冲，适用于直接传递的场景   |

以BlockingQueue为例：

```java
// 其中，Linked是有界的；
BlockingQueue<T> taskQueue = new LinkedBlockingQueue<>();

// 使用就是简单的put、take。即放入和取出
taskQueue.put(T);
T temp = taskQueue.take();
```



### 10、线程

#### 一、创建线程

##### 1. Thread类

重写run即可：

```java
public class MyThread extends Thread {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start(); // 启动线程
    }
}
```

可以显示的创建线程（==不推荐==)：

```java
Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                
            }
        });
thread.start();
```



##### 2. Runnable类

重写run，并将创建的示例传递给Thread：

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 线程执行的代码
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // 启动线程
    }
}
```



##### 3. Callable

类似于Runable，但可以返回结果，并抛出异常：

ExecutorService，相对于线程管理api。

Future，相对于这个线程的实例管理，可以通过这个实例获取线程的执行等其他状态。

```java
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        // 线程执行的代码
        return "Callable result";
    }
}

public class Main {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        MyCallable myCallable = new MyCallable();
        Future<String> future = executor.submit(myCallable);
        
        String result = future.get(); // 获取结果
        System.out.println(result);
        
        executor.shutdown(); // 关闭执行器
    }
}
```



#### 二、管理线程

##### 1、Thread用法

```java
start()：			启动线程，调用线程的 run 方法。
run()：				线程运行的代码。
join()：				等待线程终止。
sleep(long millis)：	使当前线程休眠指定的毫秒数。
interrupt()：		中断线程。
```



##### 2、ExecutorService

类别：

```java
Executors.newFixedThreadPool(10);		固定线程池
Executors.newSingleThreadExecutor();	单线程池
Executors.newCachedThreadPool();		缓存线程池
Executors.newScheduledThreadPool(5);	调度线程池
```

使用：创建5个大小的调度线程池，

```java
// 创建5跟大小的线程池
ScheduledExecutorService service = Executors.newScheduledThreadPool(5);

// 提交Runnable任务
service.execute(Runnable);
// 提交Callable任务，并获得Future实例
Future<String> future = service.submit(Callable);

// 关闭线程池
fixedThreadPool.shutdown();



```



##### 3. Future

管理通过ExecutorService创建Callable线程：

```java
// 阻塞直到任务完成
future.get();

// 取消任务；true表示立即中断正在执行的任务
future.cancel(true); 

// 检查是否完成
future.isDone();

// 检查是否被取消
future.isCancelled();
```



#### 3、线程同步和安全

##### 1. synchronized

在代码块或方法中使用关键字，确保同一时刻只有一个线程访问该代码：

```java
private int count = 0;

public synchronized void increment() {
	count++;
}
```



##### 2. ReentrantLock

可重入互斥锁：

```java
private int count = 0;
private ReentrantLock lock = new ReentrantLock();

public void increment() {
    lock.lock();
    	try {
    	count++;
    } finally {
    	lock.unlock();
    }
}
```



### 11、注解

##### 1. 条件注解

```java
@ConditionOnxxx			// 其中xxx为bean、class、等等
@ConditionOnMissingxxx	

eg. 如果存在User这个类则创建Temp这个bean
@ConditionOnClass(name="com.entity.User")
@Bean
public Temp Temp(){
	return new Temp()
}
```



##### 2. 属性绑定

@ConfigurationProperties或使用@EnableConfigurationProperties()

```java
// 使用@ConfigurationProperties()来表示与配置文件中的进行绑定
eg. 使用prefix将pig前缀的配置与类中的属性进行绑定

@ConfigurationProperties(prefix = "pig")
@Component
public class pig(){
	private Long id;
	private String name;
}

// 配置文件：
pig.id=1
pig.name="haha"

// @EnableConfigurationProperties()其实就是上面那个加一个bean，主要用于第三方库的配置
```



### 12、日志

默认有日志，为logback。

#### 1. 等级

```
trace
debug
info
warn
error
```



#### 2. 使用

```java
// 通过日志工厂获得日志对象
Logger logger = LoggerFactory.getLogger(getClass());
logger.info("测试");

// 在bean上注解@Slf4j，使用自动注入的log
@Slf4j
@RestController
public class TContorller{
	@GetMapping("/test")
	public String test(){
		log.info("测试");
		return "测试";
	}
}
```



#### 3.修改默认框架

```xml
<dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>
     <exclusions>
         <exclusion>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-logging</artifactId>
         </exclusion>
     </exclusions>
 </dependency>
 
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-log4j2</artifactId>
 </dependency>
```



#### 4. 配置

```properties
# 在配置文件中，使用logging开头的配置
# eg. 修改时间格式
logging.pattern.dateformat=yyyy-MM-dd HH:mm:ss.SSS

# eg. 分组级别
logging.group.xxx=包名1,包名2...
logging.level.xxx=debug

# eg. 输出日志文件，默认路径为根目录。name比path优先度高，使用name即可
logging.file.name=xxx
logging.file.path=xxx

# eg. 归档、切割。切割名为日期加第几份，每份最大为10MB,最长保存7天
loggin.logback.rollingpolicy.file-name-pattern=${LOG_FILE}.$d{yyyy-MM-dd}.%i.gz
loggin.logback.rollingpolicy.max-file-size=10MB
loggin.logback.rollingpolicy.max-history=7


```



#### 5.框架配置

可以在resource下存放框架配置文件，名字符合规范就会默认加载该配置文件，而不是使用默认配置。

```
eg. logback的框架配置文件
logback-spring.xml
```



### 13、maven

启用spring-boot-starter后，会导入许多默认框架，可以移除默认框架再引入新框架。

```xml
eg. 以移除默认日志框架logback，引入log4j2为例
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter</artifactId>
     <exclusions>
         <exclusion>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-logging</artifactId>
         </exclusion>
     </exclusions>
 </dependency>
 
 <dependency>
     <groupId>org.springframework.boot</groupId>
     <artifactId>spring-boot-starter-log4j2</artifactId>
 </dependency>
```



### 14、MVC配置

创建一个Confiuration注解的配置来实现WebMvcConfigurer接口

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
	
}
```

![image-20240707155201698](./assets/image-20240707155201698.png)

### 15、配置文件

可以使用application.properties或者application.yaml来进行配置。推荐使用yaml配置，结构清晰。



### 16、内容协商

底层的实现是由WebMvcConfigurationSupport

#### 1、返回内容

##### 1、xml

在实体类中添加注解：

```java
@JacksonXmlRootElement
@Data
public class Person{
    String name;
    Integer age;
}
```

添加依赖

```xml
 <dependency>
     <groupId>com.fasterxml.jackson.dataformat</groupId>
     <artifactId>jackson-dataformat-xml</artifactId>
 </dependency>
```

##### 2、其他协议

如yaml

添加依赖

```xml
 <dependency>
     <groupId>com.fasterxml.jackson.dataformat</groupId>
     <artifactId>jackson-dataformat-yaml</artifactId>
 </dependency>
```

添加配置

```properties
// 增加一种类型，名字为xxx。如：ymal
spring.mvc.contentnegotiation.media-types.xxx=application/xxx
```

 xxx 实现`AbstractHttpMessageConverter<Object>` 

```java
// 其中，supports是所支持的类型，可以使用判断，如果支持就return true；基本上除了基本类型都可以支持
// readInterna 是后端接收时的转换
// writeInternal 是发送时的转换w
```

在MVC配置中添加拓展Message：

```java
public void configureMessageConverters(List<HttpMessageConverter<?>> converter){
	converter.add(xxx)
}
```



#### 2、协商方式

两种协商方式：

##### 1、http协商

第一种是可以使用http的accept属性设置，如accept:applacation/json，返回json。

##### 2、参数协商

默认关闭，需要开启配置。在url中带上format参数，如：/person?format=xml。

```properties
spring.mvc.contentnegotiation.favor-parameter=true
```



### 17、Thymeleaf模板引擎

```
${}		// 用来获取变量
@{}		// 用来使用url路径
...
```

可以使用工具类，可以参照官网。使用#来使用

```html
// 转化为大写
${#string.toUpperCase(name)}

// 还有session、param、application
```



#### 模板布局

用于例如导航栏等公共布局。与vue中的组件相似。

创建片段，使用`th:fragment`来创建。

```html
// 创建一个判断，在可以新建一个html来保存，如xxx.html
<header th:fragment="myheader" ...>
	...
</header>
```

使用判断，使用`th:replace`来进行替换。替换名为`~{模板名::片段名}`。

```html
// 将div替换为上面的片段，如导航栏
<div th:replace="~{xxx :: myheader}" ...>
</div>
```



#### 国际化

在template目录下新建`messages.properties`，表示国际化的配置文件。其中配置默认配置。

中文环境为`messages_zh_CN.properties`。

英文环境为`messages_en_US.properties`。

```properties
# messages.properties 文件
login=login
sing-up=sing-up

# messages_zh_CN.properties 文件
login=登录
sing-up=注册

# messages_en_US.properties 文件
login=login
sing-up=sing-up
```

接着在html中使用`#{}`来获取对应key的value

```html
// 此时会根据用户语言进行切换
<div th:text="#{login}"></div>
```



### 18、错误处理

在遇到错误时，默认是SpringMVC来进行错误处理。默认是没有。再交给springBoot进行处理。默认是白页。

如果发生了错误码的错误，会自动去template下的/error/错误码.html下渲染。

如果没有错误码.html，则去找5xx.html/4xx.html。

再没有，就到error错误视图，这是默认的。

#### 自定义错误处理

##### 类中的错误处理

使用`@ExceptionHandler(xxx错误类型)`。

```java
//使用@ExceptionHandler(Exception.class)
@ResponseBody
@ExceptionHandler(Exception.class)
public String handeException(Exception e){
	return "遇到错误："+e.getMessage();
}
```



##### 全局错误处理

使用`@ControllerAdvice`，注解在类上

```java
@ControllerAdvice
public class GlobalExceptionHandler{
    @ResponseBody
	@ExceptionHandler(Exception.class)
    public String handeException(Exception e){
		return "统一处理，遇到错误："+e.getMessage();
	}
}
```









### 底部











---



# 微信后端

```java
 // appid和secret为公众号开发者设置中获取
  // 接收前端发送的请求，接收code参数，再通过code向腾讯发起请求，接收到access_token，通过这个获取用户信息
 	@ResponseBody
    @GetMapping("/login")
    public void wxH5(@RequestParam("code") String code){
        System.out.println("code ::: "+code);
//        发送请求
        String temp_token = HttpTemplate.httpGet("https://api.weixin.qq.com/sns/oauth2/access_token?"
                + "appid="+ appid
                + "&secret="+secret
                + "&code="+code
                + "&grant_type=authorization_code");
        // 使用 Gson 解析 JSON 字符串为 Token 对象
        Gson gson = new Gson();
        Token token = gson.fromJson(temp_token, Token.class);
        System.out.println("temp_token ::"+temp_token);
        System.out.println("token ::: "+token);

        // 获取用户信息
        System.out.println("getopenid::"+token.getOpenid());
        String user = HttpTemplate.httpGet("https://api.weixin.qq.com/sns/userinfo?" +
                "access_token=" + token.getAccess_token() +"&openid="+token.getOpenid()+"&lang=zh_CN");
        System.out.println("user ::: "+user);
    }
```

前端：

```js
goFunctionClick(flag){
    var url = 'http://10.177.13.153:8080/pages/my/my';
    var encodedUrl = encodeURIComponent(url);
    console.log(encodedUrl);
    window.location.href='https://open.weixin.qq.com/connect/oauth2/authorize?appid=wxa079e1c44eb5786b&'+
    'redirect_uri='+encodedUrl+'&response_type=code&scope=snsapi_userinfo&state=STATE#wechat_redirect';

}
```



---



# frp内网穿透

## 前提准备

云服务器一台，可选择云服务器、轻量型服务器、vps。

## 开始

在服务器中下载对应的 ==frp== 版本。：[frp github](https://github.com/fatedier/frp)

这里以0.53.2为例

### 1、服务器

下载好后，直接运行下面这个shell文件即可。会在运行目录下生成一个 ${dirname} 变量的目录。

若要修改下载的 frp 版本，需修改第 4、5行的对应frp版本号。

若要修改服务器监听端口，修改40行的对应值。

```shell
#!/bin/bash

# 下载资源的URL
version="0.53.2"
name="frp_0.53.2_linux_amd64.tar.gz"
dirname=$(basename "$name" .tar.gz)
url="https://github.com/fatedier/frp/releases/download/v${version}/${name}"

echo $url

if ls *frp* 1> /dev/null 2>&1; then
    echo "文件存在"
else
    echo "文件不存在"
     # 下载资源
    wget --timeout=600 --quiet --show-progress "$url"
    # 检查wget的返回码
    if [ $? -eq 0 ]; then
        echo "下载完成"
        # 解压文件
    else
        echo "下载失败"
        exit
        # 在这里可以添加下载失败后的处理逻辑
    fi
fi

if [ -d "$dirname" ]; then
    echo "目录存在"
else
    echo "目录不存在"
    tar -zxf "$name"
fi

cd "$dirname"
rm -rf frpc frpc.toml
# bindPort 是云服务器监听的端口，需开放
# vhostHTTPPort 是对外http服务的端口，vhostHTTPSPort 同理。若不需要http或https，可去掉这两行
echo "" > frps.toml
echo -e "bindPort=7000\nvhostHTTPPort=80\nvhostHTTPSPort=443\n" > frps.toml
nohup ./frps -c frps.toml &
sleep 1
pid=$(pgrep -f "frps")
if [ -z "$pid" ]; then
    echo "frps服务未启动，请自行启动"
else
    echo "frps进程pid的值为 $pid"
    rm -f frps-pid*
    touch "frps-pid-${pid}"
fi
```

设置服务

```
sudo vim /etc/systemd/system/frps.service
```

```shell
[Unit]
# 服务名称，可自定义
Description = frp server
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
# 启动frps的命令，需修改为您的frps的安装路径
ExecStart = /path/to/frps -c /path/to/frps.toml

[Install]
WantedBy = multi-user.target

```

```
sudo systemctl start frps
sudo systemctl enable frps
```



### 2、内网主机

最好下载与服务器对应版本的 frp。

下载对应系统版本的 frp。

#### windows版本

解压出来后，进入frpc.exe所在目录，可以创建一个文件bat。执行下面命令

其中第8行的xxx需要修改为对应的云服务器的公网ip

第24行中的xx.domin.xx需要修改为对应域名，ip或许可以。

```
@echo off
set filename=frpc.toml
del frps
del frps.toml

touch e.txt
(
echo serverAddr = "xxx.xxx.xxx.xxx" 
echo serverPort = 7000

echo # ssh连接
echo [[proxies]]
echo name = "ssh"
echo type = "tcp"
echo localIP = "127.0.0.1"
echo localPort = 22
echo remotePort = 6000

echo  # http服务
echo [[proxies]]
echo name = "web"
echo type = "http"
echo localPort = 80
echo customDomains = ["xxx.domin.xxx"]
) > frpc.toml
./frpc -c frpc.toml
```

#### linux版本

直接在压缩包目录中执行这个bash文件。

需要修改版本：version和name中对应版本的字段。

需要修改服务：修改39行起的字段。

```shell
#!/bin/bash

# 下载资源的URL
version="0.53.2"
name="frp_0.53.2_linux_amd64.tar.gz"
dirname=$(basename "$name" .tar.gz)
url="https://github.com/fatedier/frp/releases/download/v${version}/${name}${back}"

echo $url

if ls *frp* 1> /dev/null 2>&1; then
    echo "文件存在"
else
    echo "文件不存在"
     # 下载资源
    wget --timeout=600 --quiet --show-progress "$url"
    # 检查wget的返回码
    if [ $? -eq 0 ]; then
        echo "下载完成"
        # 解压文件
    else
        echo "下载失败"
        exit
        # 在这里可以添加下载失败后的处理逻辑
    fi
fi

if [ -d "$dirname" ]; then
    echo "目录存在"
else
    echo "目录不存在"
    tar -zxf "$name"
fi

cd "$dirname"
rm -rf frps frps.toml

echo "" > frpc.toml
echo  'serverAddr = "123.58.220.74"
serverPort = 7000
# ssh连接
[[proxies]]
name = "ssh"
type = "tcp"
localIP = "127.0.0.1"
localPort = 22
remotePort = 6000

# http服务
[[proxies]]
name = "web"
type = "http"
localPort = 80
customDomains = ["www.boheqiaokeli.com"]
' > frpc.toml
nohup ./frpc -c frpc.toml &
sleep 1
pid=$(pgrep -f "frpc")
if [ -z "$pid" ]; then
    echo "frpc服务未启动，请自行启动"
else
    echo "frpc进程pid的值为 $pid"
    rm -f frpc-pid*
    touch "frpc-pid-${pid}"
fi
```

---





# 底部





# 问题：

## mysql：

### 1、删库错误：1010 - Error dropping database (can't rmdir ' auto@002dguide', errno: 41)

删除数据库时出错。直接进入数据库的Data目录，删除对应名称的数据库。❗❗❗❗❗该过程不可逆，注意使用❗❗❗❗❗



## maven

#### 1、pom.xml中Respositores配置不起作用

<font title="red">问题描述</font> ：在maven项目中的pom.xml配置其他远程仓库Respositores不起作用，默认从alibaba镜像仓库中下载

<font title="blue">解决</font> ：找到maven配置文件 ==con->setting.xml== ，修改 ==mirror== 。如图2，为原本的配置，mirrorOf指的是配置所有的远程仓库都指向下面的url。可以使用匹配的方式来取消其他远程仓库。如图3，本次项目需要使用 ==jitpack.io== 的远程仓库，即在mirrorOf后添加 ==,!jitpack.io== 。表示id为jitpack.io的远程仓库除外。

```
// 即如下，其他id的远程仓库默认跳转到maven中，除了id为jitpack.io的远程仓库
<mirror>
    <id>alimaven</id>
    <mirrorOf>*,!jitpack.io</mirrorOf>
    <name>aliyun maven</name>
    <url>http://maven.aliyun.com/nexus/content/groups/public</url>
</mirror>
```

![image-20240518104215897](./assets/image-20240518104215897.png)

![image-20240518104353745](./assets/image-20240518104353745.png)











